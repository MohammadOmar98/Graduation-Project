(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/router'), require('rxjs'), require('rxjs/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('xng-breadcrumb', ['exports', '@angular/core', '@angular/router', 'rxjs', 'rxjs/operators', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['xng-breadcrumb'] = {}, global.ng.core, global.ng.router, global.rxjs, global.rxjs.operators, global.ng.common));
}(this, (function (exports, i0, i1, rxjs, operators, common) { 'use strict';

    /**
     * This directive is used to customize the breadcrumb label behavior
     * *xngBreadcrumbItem directive can be used in the child element of xng-breadcrumb
     * Usage: refer to the demo - app.component.html
     */
    var BreadcrumbItemDirective = /** @class */ (function () {
        function BreadcrumbItemDirective() {
        }
        return BreadcrumbItemDirective;
    }());
    BreadcrumbItemDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[xngBreadcrumbItem]',
                },] }
    ];

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var PATH_PARAM = {
        PREFIX: ':',
        REGEX_IDENTIFIER: '/:[^/]+',
        REGEX_REPLACER: '/[^/]+',
    };
    var ALIAS_PREFIX = '@';
    var isNonEmpty = function (obj) {
        return obj && Object.keys(obj).length > 0;
    };
    var ɵ0 = isNonEmpty;
    var BreadcrumbService = /** @class */ (function () {
        function BreadcrumbService(activatedRoute, router) {
            this.activatedRoute = activatedRoute;
            this.router = router;
            this.baseHref = '/';
            /**
             * dynamicBreadcrumbStore holds information about dynamically updated breadcrumbs.
             * Breadcrumbs can be set from anywhere (component, service) in the app.
             * On every breadcrumb update check this store and use the info if available.
             */
            this.dynamicBreadcrumbStore = [];
            /**
             * breadcrumbList for the current route
             * When breadcrumb info is changed dynamically, check if the currentBreadcrumbs is effected
             * If effected, update the change and emit a new stream
             */
            this.currentBreadcrumbs = [];
            this.previousBreadcrumbs = [];
            /**
             * Breadcrumbs observable to be subscribed by BreadcrumbComponent
             * Emits on every route change OR dynamic update of breadcrumb
             */
            this.breadcrumbs = new rxjs.BehaviorSubject([]);
            this.breadcrumbs$ = this.breadcrumbs.asObservable();
            this.detectRouteChanges();
        }
        /**
         * Whenever route changes build breadcrumb list again
         */
        BreadcrumbService.prototype.detectRouteChanges = function () {
            var _this = this;
            this.router.events
                .pipe(operators.filter(function (event) { return event instanceof i1.NavigationEnd; }))
                .subscribe(function () {
                _this.previousBreadcrumbs = _this.currentBreadcrumbs;
                // breadcrumb label for base OR root path. Usually, this can be set as 'Home'
                var rootBreadcrumb = _this.getRootBreadcrumb();
                _this.currentBreadcrumbs = rootBreadcrumb ? [rootBreadcrumb] : [];
                _this.prepareBreadcrumbList(_this.activatedRoute.root, _this.baseHref);
            });
        };
        BreadcrumbService.prototype.getRootBreadcrumb = function () {
            var _a;
            var rootConfig = this.router.config.find(function (config) { return config.path === ''; });
            var rootBreadcrumb = this.extractObject((_a = rootConfig === null || rootConfig === void 0 ? void 0 : rootConfig.data) === null || _a === void 0 ? void 0 : _a.breadcrumb);
            var storeItem = this.getFromStore(rootBreadcrumb.alias, '/');
            if (isNonEmpty(rootBreadcrumb) || isNonEmpty(storeItem)) {
                return Object.assign(Object.assign(Object.assign(Object.assign({}, storeItem), rootBreadcrumb), { routeLink: this.baseHref }), this.getQueryParamsFromPreviousList('/'));
            }
        };
        BreadcrumbService.prototype.prepareBreadcrumbItem = function (activatedRoute, routeLinkPrefix) {
            var _b = this.parseRouteData(activatedRoute.routeConfig), path = _b.path, breadcrumb = _b.breadcrumb;
            var resolvedSegment = this.resolvePathSegment(path, activatedRoute);
            var routeLink = "" + routeLinkPrefix + resolvedSegment;
            var storeItem = this.getFromStore(breadcrumb.alias, routeLink);
            var label = this.extractLabel((storeItem === null || storeItem === void 0 ? void 0 : storeItem.label) || (breadcrumb === null || breadcrumb === void 0 ? void 0 : breadcrumb.label), resolvedSegment);
            var isAutoGeneratedLabel = false;
            var autoGeneratedLabel = '';
            if (!label) {
                isAutoGeneratedLabel = true;
                autoGeneratedLabel = resolvedSegment;
            }
            return Object.assign(Object.assign(Object.assign(Object.assign({}, storeItem), breadcrumb), { label: isAutoGeneratedLabel ? autoGeneratedLabel : label, routeLink: routeLink,
                isAutoGeneratedLabel: isAutoGeneratedLabel }), this.getQueryParamsFromPreviousList(routeLink));
        };
        BreadcrumbService.prototype.prepareBreadcrumbList = function (activatedRoute, routeLinkPrefix) {
            if (activatedRoute.routeConfig && activatedRoute.routeConfig.path) {
                var breadcrumbItem = this.prepareBreadcrumbItem(activatedRoute, routeLinkPrefix);
                this.currentBreadcrumbs.push(breadcrumbItem);
                if (activatedRoute.firstChild) {
                    return this.prepareBreadcrumbList(activatedRoute.firstChild, breadcrumbItem.routeLink + '/');
                }
            }
            else if (activatedRoute.firstChild) {
                return this.prepareBreadcrumbList(activatedRoute.firstChild, routeLinkPrefix);
            }
            var lastCrumb = this.currentBreadcrumbs[this.currentBreadcrumbs.length - 1];
            this.setQueryParamsForActiveBreadcrumb(lastCrumb, activatedRoute);
            // remove breadcrumb items that needs to be hidden
            var breadcrumbsToShow = this.currentBreadcrumbs.filter(function (item) { return !item.skip; });
            this.breadcrumbs.next(breadcrumbsToShow);
        };
        BreadcrumbService.prototype.getFromStore = function (alias, routeLink) {
            var _this = this;
            return this.dynamicBreadcrumbStore.find(function (item) {
                return ((alias && alias === item.alias) ||
                    (routeLink && routeLink === item.routeLink) ||
                    _this.matchRegex(routeLink, item.routeRegex));
            });
        };
        /**
         * use exact match instead of regexp.test
         * for /mentor/[^/]+ we should match '/mentor/12' but not '/mentor/12/abc'
         */
        BreadcrumbService.prototype.matchRegex = function (routeLink, routeRegex) {
            var match = routeLink.match(new RegExp(routeRegex));
            return match && match[0] === routeLink;
        };
        /**
         * if the path segment has route params, read the param value from url
         * for each segment of route this gets called
         *
         * for mentor/:id/view - it gets called with mentor, :id, view 3 times
         */
        BreadcrumbService.prototype.resolvePathSegment = function (segment, activatedRoute) {
            //quirk -segment can be defined as view/:id in route config in which case you need to make it view/<resolved-param>
            if (segment.includes(PATH_PARAM.PREFIX)) {
                Object.entries(activatedRoute.snapshot.params).forEach(function (_b) {
                    var _c = __read(_b, 2), key = _c[0], value = _c[1];
                    segment = segment.replace(":" + key, "" + value);
                });
            }
            return segment;
        };
        /**
         * queryParams & fragments for previous breadcrumb path are copied over to new list
         */
        BreadcrumbService.prototype.getQueryParamsFromPreviousList = function (routeLink) {
            var _b = this.previousBreadcrumbs.find(function (item) { return item.routeLink === routeLink; }) ||
                {}, queryParams = _b.queryParams, fragment = _b.fragment;
            return { queryParams: queryParams, fragment: fragment };
        };
        /**
         * set current activated route query params to the last breadcrumb item
         */
        BreadcrumbService.prototype.setQueryParamsForActiveBreadcrumb = function (lastItem, activatedRoute) {
            if (lastItem) {
                var _b = activatedRoute.snapshot, queryParams = _b.queryParams, fragment = _b.fragment;
                lastItem.queryParams = queryParams ? Object.assign({}, queryParams) : undefined;
                lastItem.fragment = fragment;
            }
        };
        /**
         * For a specific route, breadcrumb can be defined either on parent OR it's child(which has empty path)
         * When both are defined, child takes precedence
         *
         * Ex: Below we are setting breadcrumb on both parent and child.
         * So, child takes precedence and "Defined On Child" is displayed for the route 'home'
         * { path: 'home', loadChildren: './home/home.module#HomeModule' , data: {breadcrumb: "Defined On Module"}}
         *                                                AND
         * children: [
         *   { path: '', component: ShowUserComponent, data: {breadcrumb: "Defined On Child" }
         * ]
         */
        BreadcrumbService.prototype.parseRouteData = function (routeConfig) {
            var path = routeConfig.path, data = routeConfig.data;
            var breadcrumb = this.mergeWithBaseChildData(routeConfig, data === null || data === void 0 ? void 0 : data.breadcrumb);
            return { path: path, breadcrumb: breadcrumb };
        };
        /**
         * get empty children of a module or Component. Empty child is the one with path: ''
         * When parent and it's children (that has empty route path) define data merge them both with child taking precedence
         */
        BreadcrumbService.prototype.mergeWithBaseChildData = function (routeConfig, config) {
            var _a;
            if (!routeConfig) {
                return this.extractObject(config);
            }
            var baseChild;
            if (routeConfig.loadChildren) {
                // To handle a module with empty child route
                baseChild = routeConfig._loadedConfig.routes.find(function (route) { return route.path === ''; });
            }
            else if (routeConfig.children) {
                // To handle a component with empty child route
                baseChild = routeConfig.children.find(function (route) { return route.path === ''; });
            }
            var childConfig = (_a = baseChild === null || baseChild === void 0 ? void 0 : baseChild.data) === null || _a === void 0 ? void 0 : _a.breadcrumb;
            return childConfig
                ? this.mergeWithBaseChildData(baseChild, Object.assign(Object.assign({}, this.extractObject(config)), this.extractObject(childConfig)))
                : this.extractObject(config);
        };
        /**
         * Update breadcrumb dynamically
         *
         * key can be a path | alias
         *
         * 1) Using complete route path. route can be passed the same way you define angular routes
         * - path can be passed as 'exact path(routeLink)' or 'path with params(routeRegex)'
         * - update label Ex: set('/mentor', 'Mentor'), set('/mentor/:id', 'Mentor Details')
         * - change visibility Ex: set('/mentor/:id/edit', { skip: true })
         * ------------------------------------------ OR ------------------------------------------
         * 2) Using route alias (prefixed with '@'). alias should be unique for a route
         * - update label Ex: set('@mentor', 'Enabler')
         * - change visibility Ex: set('@mentorEdit', { skip: true })
         *
         *
         * value can be string | BreadcrumbObject | BreadcrumbFunction
         */
        BreadcrumbService.prototype.set = function (key, breadcrumb) {
            var breadcrumbObject = this.extractObject(breadcrumb);
            var updateArgs;
            if (key.startsWith(ALIAS_PREFIX)) {
                updateArgs = ['alias', Object.assign(Object.assign({}, breadcrumbObject), { alias: key.slice(1) })];
            }
            else if (key.includes(PATH_PARAM.PREFIX)) {
                updateArgs = [
                    'routeRegex',
                    Object.assign(Object.assign({}, breadcrumbObject), { routeRegex: this.buildRegex(key) }),
                ];
            }
            else {
                updateArgs = [
                    'routeLink',
                    Object.assign(Object.assign({}, breadcrumbObject), { routeLink: this.ensureLeadingSlash(key) }),
                ];
            }
            this.updateStore.apply(this, __spread(updateArgs));
            this.updateCurrentBreadcrumbs.apply(this, __spread(updateArgs));
        };
        /**
         * Update the store to reuse for dynamic declarations
         * If the store already has this route definition update it, else add
         */
        BreadcrumbService.prototype.updateStore = function (key, breadcrumb) {
            var storeItemIndex = this.dynamicBreadcrumbStore.findIndex(function (item) {
                return breadcrumb[key] === item[key];
            });
            if (storeItemIndex > -1) {
                this.dynamicBreadcrumbStore[storeItemIndex] = Object.assign(Object.assign({}, this.dynamicBreadcrumbStore[storeItemIndex]), breadcrumb);
            }
            else {
                this.dynamicBreadcrumbStore.push(Object.assign({}, breadcrumb));
            }
        };
        /**
         * If breadcrumb is present in current breadcrumbs update it and emit new stream
         */
        BreadcrumbService.prototype.updateCurrentBreadcrumbs = function (key, breadcrumb) {
            var _this = this;
            var itemIndex = this.currentBreadcrumbs.findIndex(function (item) {
                return key === 'routeRegex'
                    ? _this.matchRegex(item.routeLink, breadcrumb[key])
                    : breadcrumb[key] === item[key];
            });
            if (itemIndex > -1) {
                this.currentBreadcrumbs[itemIndex] = Object.assign(Object.assign({}, this.currentBreadcrumbs[itemIndex]), breadcrumb);
                var breadcrumbsToShow = this.currentBreadcrumbs.filter(function (item) { return !item.skip; });
                this.breadcrumbs.next(__spread(breadcrumbsToShow));
            }
        };
        /**
         * For a route with path param, we create regex dynamically from angular route syntax
         * '/mentor/:id' becomes '/mentor/[^/]',
         * breadcrumbService.set('/mentor/:id', 'Uday') should update 'Uday' as label for '/mentor/2' OR 'mentor/ada'
         */
        BreadcrumbService.prototype.buildRegex = function (path) {
            return this.ensureLeadingSlash(path).replace(new RegExp(PATH_PARAM.REGEX_IDENTIFIER, 'g'), PATH_PARAM.REGEX_REPLACER);
        };
        BreadcrumbService.prototype.ensureLeadingSlash = function (path) {
            return path.startsWith('/') ? path : "/" + path;
        };
        /**
         * In App's RouteConfig, breadcrumb can be defined as a string OR a function OR an object
         *
         * string: simple static breadcrumb label for a path
         * function: callback that gets invoked with resolved path param
         * object: additional data defined along with breadcrumb label that gets passed to *xngBreadcrumbItem directive
         */
        BreadcrumbService.prototype.extractLabel = function (config, resolvedParam) {
            var label = typeof config === 'object' ? config.label : config;
            if (typeof label === 'function') {
                return label(resolvedParam);
            }
            return label;
        };
        BreadcrumbService.prototype.extractObject = function (config) {
            // don't include {label} if config is undefined. This is important since we merge the configs
            if (config &&
                (typeof config === 'string' || typeof config === 'function')) {
                return { label: config };
            }
            return config || {};
        };
        return BreadcrumbService;
    }());
    BreadcrumbService.ɵprov = i0.ɵɵdefineInjectable({ factory: function BreadcrumbService_Factory() { return new BreadcrumbService(i0.ɵɵinject(i1.ActivatedRoute), i0.ɵɵinject(i1.Router)); }, token: BreadcrumbService, providedIn: "root" });
    BreadcrumbService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    BreadcrumbService.ctorParameters = function () { return [
        { type: i1.ActivatedRoute },
        { type: i1.Router }
    ]; };

    var BreadcrumbComponent = /** @class */ (function () {
        function BreadcrumbComponent(breadcrumbService, router) {
            this.breadcrumbService = breadcrumbService;
            this.router = router;
            this._separator = '/';
            /**
             * If true, breadcrumb is auto generated even without any mapping label
             * Default label is same as route segment
             */
            this.autoGenerate = true;
            /**
             * By default query params will be preserved with breadcrumbs
             */
            this.preserveQueryParams = true;
            /**
             * By default query fragments will be preserved with breadcrumbs
             */
            this.preserveFragment = true;
            /**
             * custom class provided by consumer to increase specificity
             * This will benefit to override styles that are conflicting
             */
            this.class = '';
        }
        Object.defineProperty(BreadcrumbComponent.prototype, "separator", {
            get: function () {
                return this._separator;
            },
            /**
             * separator between breadcrumbs, defaults to '/'.
             * User can customize separator either by passing a String or Template
             *
             * String --> Ex: <xng-breadcrumb separator="-"> </xng-breadcrumb>
             *
             * Template --> Ex: <xng-breadcrumb [separator]="separatorTemplate"> </xng-breadcrumb>
             * <ng-template #separatorTemplate><mat-icon>arrow_right</mat-icon></ng-template>
             */
            set: function (value) {
                if (value instanceof i0.TemplateRef) {
                    this.separatorTemplate = value;
                    this._separator = undefined;
                }
                else {
                    this.separatorTemplate = undefined;
                    this._separator = value || '/';
                }
            },
            enumerable: false,
            configurable: true
        });
        BreadcrumbComponent.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription = this.breadcrumbService.breadcrumbs$.subscribe(function (breadcrumbs) {
                _this.breadcrumbs = breadcrumbs
                    .map(function (breadcrumb) {
                    // Do not mutate breadcrumb as its source of truth.
                    // There can be scenarios where we can have multiple xng-breadcrumb instances in page
                    return Object.assign(Object.assign({}, breadcrumb), { queryParams: _this.preserveQueryParams
                            ? breadcrumb.queryParams
                            : undefined, fragment: _this.preserveFragment ? breadcrumb.fragment : undefined });
                })
                    .filter(function (breadcrumb) {
                    // Usually, breadcrumb list can contain a combination of auto generated and user specified labels
                    // this filters autogenerated labels in case of "[autoGenerate]: false"
                    if (_this.autoGenerate) {
                        return true;
                    }
                    return !breadcrumb.isAutoGeneratedLabel;
                });
            });
        };
        BreadcrumbComponent.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        BreadcrumbComponent.prototype.handleRoute = function (breadcrumb) {
            var routeLink = breadcrumb.routeInterceptor
                ? breadcrumb.routeInterceptor(breadcrumb.routeLink, breadcrumb)
                : breadcrumb.routeLink;
            var queryParams = breadcrumb.queryParams, fragment = breadcrumb.fragment;
            this.router.navigate([routeLink], { queryParams: queryParams, fragment: fragment });
        };
        return BreadcrumbComponent;
    }());
    BreadcrumbComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'xng-breadcrumb',
                    template: "<nav aria-label=\"breadcrumb\" class=\"xng-breadcrumb-root\" [ngClass]=\"class\">\n  <ol class=\"xng-breadcrumb-list\">\n    <ng-container\n      *ngFor=\"\n        let breadcrumb of breadcrumbs; \n        last as isLast; \n        first as isFirst; \n        index as index; \n        count as count;\">\n      <li class=\"xng-breadcrumb-item\">\n        <a\n          *ngIf=\"!isLast\"\n          (click)=\"handleRoute(breadcrumb)\"\n          class=\"xng-breadcrumb-link\"\n          [ngClass]=\"{ 'xng-breadcrumb-link-disabled': breadcrumb.disable }\"\n          [attr.aria-disabled]=\"breadcrumb.disable\"\n        >\n          <ng-container\n            *ngTemplateOutlet=\"\n              itemTemplate;\n              context: {\n                $implicit: breadcrumb.label,\n                info: breadcrumb.info,\n                last: isLast,\n                first: isFirst,\n                index: index,\n                count: count\n              }\n            \"\n          ></ng-container>\n          <ng-container *ngIf=\"!itemTemplate\">{{\n            breadcrumb.label\n          }}</ng-container>\n        </a>\n\n        <label *ngIf=\"isLast\" class=\"xng-breadcrumb-trail\">\n          <ng-container\n            *ngTemplateOutlet=\"\n              itemTemplate;\n              context: {\n                $implicit: breadcrumb.label,\n                info: breadcrumb.info,\n                last: isLast,\n                first: isFirst,\n                index: index,\n                count: count\n              }\n            \"\n          ></ng-container>\n          <ng-container *ngIf=\"!itemTemplate\">{{\n            breadcrumb.label\n          }}</ng-container>\n        </label>\n      </li>\n\n      <li\n        *ngIf=\"!isLast\"\n        class=\"xng-breadcrumb-separator\"\n        aria-hidden=\"true\"\n        role=\"separator\"\n      >\n        <ng-container *ngTemplateOutlet=\"separatorTemplate\"></ng-container>\n        <ng-container *ngIf=\"!separatorTemplate\">{{ separator }}</ng-container>\n      </li>\n    </ng-container>\n  </ol>\n</nav>\n",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: [".xng-breadcrumb-root{color:rgba(0,0,0,.6);margin:0}.xng-breadcrumb-list{align-items:center;display:flex;flex-wrap:wrap;margin:0;padding:0}.xng-breadcrumb-item{list-style:none}.xng-breadcrumb-trail{align-items:center;color:rgba(0,0,0,.9);display:flex}.xng-breadcrumb-link{align-items:center;color:inherit;display:flex;text-decoration:none;transition:-webkit-text-decoration .3s;transition:text-decoration .3s;transition:text-decoration .3s,-webkit-text-decoration .3s;white-space:nowrap}.xng-breadcrumb-link:hover{text-decoration:underline}.xng-breadcrumb-link-disabled{cursor:disabled;pointer-events:none}.xng-breadcrumb-separator{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;display:flex;margin-left:8px;margin-right:8px;user-select:none}"]
                },] }
    ];
    BreadcrumbComponent.ctorParameters = function () { return [
        { type: BreadcrumbService },
        { type: i1.Router }
    ]; };
    BreadcrumbComponent.propDecorators = {
        itemTemplate: [{ type: i0.ContentChild, args: [BreadcrumbItemDirective, { static: false, read: i0.TemplateRef },] }],
        autoGenerate: [{ type: i0.Input }],
        preserveQueryParams: [{ type: i0.Input }],
        preserveFragment: [{ type: i0.Input }],
        class: [{ type: i0.Input }],
        separator: [{ type: i0.Input, args: ['separator',] }]
    };

    var BreadcrumbModule = /** @class */ (function () {
        function BreadcrumbModule() {
        }
        return BreadcrumbModule;
    }());
    BreadcrumbModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [BreadcrumbComponent, BreadcrumbItemDirective],
                    imports: [common.CommonModule, i1.RouterModule],
                    exports: [BreadcrumbComponent, BreadcrumbItemDirective],
                },] }
    ];

    /*
     * Public API Surface of xng-breadcrumb
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.BreadcrumbComponent = BreadcrumbComponent;
    exports.BreadcrumbItemDirective = BreadcrumbItemDirective;
    exports.BreadcrumbModule = BreadcrumbModule;
    exports.BreadcrumbService = BreadcrumbService;
    exports.ɵ0 = ɵ0;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=xng-breadcrumb.umd.js.map
